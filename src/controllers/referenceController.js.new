const { PrismaClient, Prisma } = require("@prisma/client");
const createError = require("http-errors");
const prisma = new PrismaClient();
const { z } = require("zod");
const validateRequest = require("../utils/validateRequest");

/**
 * Wrap async route handlers and funnel errors through Express error middleware.
 * Converts Zod validation errors and known request errors into structured 400 responses.
 */
const asyncHandler = (fn) => (req, res, next) => {
  return Promise.resolve(fn(req, res, next)).catch((err) => {
    // Zod or manual user errors forwarded by validateRequest
    if (err.status === 400 && err.expose) {
      return res
        .status(400)
        .json({ errors: err.errors || { message: err.message } });
    }
    // Prisma validation errors
    if (err.name === "PrismaClientValidationError") {
      return res.status(400).json({ errors: { message: err.message } });
    }
    // Prisma known request errors (e.g., unique constraint)
    if (err instanceof Prisma.PrismaClientKnownRequestError) {
      if (err.code === "P2002" && err.meta?.target) {
        const field = Array.isArray(err.meta.target)
          ? err.meta.target[0]
          : err.meta.target;
        const message = `A record with that ${field} already exists.`;
        return res
          .status(400)
          .json({ errors: { [field]: { type: "unique", message } } });
      }
    }
    // Fallback for unexpected errors
    console.error(err);
    return res
      .status(500)
      .json({ errors: { message: "Internal Server Error" } });
  });
};

// Parse integer helper function
const int = (v) => parseInt(v, 10);

/**
 * GET /references
 *  – giverId   → references I have GIVEN
 *  – receiverId→ references I have RECEIVED
 *  – no id     → admin list / full search
 */
const listReferences = asyncHandler(async (req, res) => {
  let {
    page = 1,
    limit = 10,
    search = "",
    sortBy = "date",
    sortOrder = "desc",
    giverId,
    receiverId,
    status,
  } = req.query;

  // Parse pagination parameters
  const parsedPage = Math.max(1, parseInt(page, 10));
  const parsedLimit = Math.max(1, parseInt(limit, 10));
  const skip = (parsedPage - 1) * parsedLimit;

  // Build where clause for filters
  const where = {};

  // Add search filter if present
  if (search && search.trim() !== "") {
    where.OR = [
      { nameOfReferral: { contains: search, mode: "insensitive" } },
      { remarks: { contains: search, mode: "insensitive" } },
    ];
  }

  // Add status filter if present
  if (status) {
    where.status = status;
  }

  // If user is a member, restrict to their own references
  if (req.user.role !== "admin" && req.user.role !== "super_admin") {
    const member = await prisma.member.findFirst({
      where: { userId: req.user.id },
      select: { id: true },
    });

    if (member) {
      if (giverId) {
        where.giverId = member.id;
      } else if (receiverId) {
        where.receiverId = member.id;
      } else {
        where.OR = [{ giverId: member.id }, { receiverId: member.id }];
      }
    } else {
      // User is not a member, so they can't see any references
      return res.json({ data: [], pagination: { totalPages: 0, totalItems: 0 } });
    }
  } else {
    // Admin users can filter by specified giverId/receiverId
    if (giverId) {
      where.giverId = parseInt(giverId, 10);
    }
    if (receiverId) {
      where.receiverId = parseInt(receiverId, 10);
    }
  }

  // Get total count
  const totalReferences = await prisma.reference.count({ where });
  const totalPages = Math.ceil(totalReferences / parsedLimit);

  // Get references
  const references = await prisma.reference.findMany({
    where,
    skip,
    take: parsedLimit,
    orderBy: { [sortBy]: sortOrder.toLowerCase() },
    include: {
      giver: { select: { memberName: true } },
      receiver: { select: { memberName: true } },
      chapter: { select: { name: true } },
    },
  });

  const payload = {
    data: references,
    pagination: {
      currentPage: parsedPage,
      totalPages,
      totalItems: totalReferences,
      hasNextPage: parsedPage < totalPages,
      hasPrevPage: parsedPage > 1,
    },
  };

  res.json(payload);
});

/**
 * Get a single reference by ID
 */
const getReferenceById = asyncHandler(async (req, res) => {
  const { id } = req.params;

  if (!id || isNaN(parseInt(id))) {
    throw createError(400, "Invalid reference ID");
  }

  const reference = await prisma.reference.findUnique({
    where: { id: int(id) },
    include: {
      giver: {
        select: {
          id: true,
          memberName: true,
          email: true,
          mobile1: true,
        },
      },
      receiver: {
        select: {
          id: true,
          memberName: true,
          email: true,
          mobile1: true,
        },
      },
      chapter: {
        select: {
          id: true,
          name: true,
        },
      },
      statusHistory: {
        orderBy: { date: "desc" },
      },
    },
  });

  if (!reference) {
    throw createError(404, "Reference not found");
  }

  res.json(reference);
});

/**
 * Create a new reference
 */
const createReference = asyncHandler(async (req, res) => {
  // Define Zod schema for reference validation
  const schema = z.object({
    date: z.string().nonempty("Date is required."),
    noOfReferences: z.string().optional(),
    chapterId: z.number().int().positive("Chapter ID is required."),
    memberId: z.number().int().positive("Member ID (receiver) is required."),
    urgency: z.string().optional(),
    self: z.union([z.boolean(), z.string()]).optional(),
    nameOfReferral: z.string().nonempty("Name of referral is required."),
    mobile1: z.string().nonempty("Primary mobile number is required."),
    mobile2: z.string().optional(),
    email: z.string().email("Must be a valid email address.").optional().nullable(),
    remarks: z.string().optional(),
    addressLine1: z.string().optional(),
    location: z.string().optional(),
    addressLine2: z.string().optional(),
    pincode: z.string().optional(),
    status: z.string().optional()
  });

  // Use validateRequest utility for validation
  const validatedData = await validateRequest(schema, req.body);

  // Check if the current user has a corresponding member record
  const member = await prisma.member.findFirst({
    where: { userId: req.user.id }
  });

  if (!member) {
    throw createError(400, "Current user does not have a corresponding member record. Cannot create reference.");
  }

  // Create the reference
  const reference = await prisma.reference.create({
    data: {
      date: new Date(validatedData.date),
      noOfReferences: validatedData.noOfReferences ? int(validatedData.noOfReferences) : null,
      chapterId: int(validatedData.chapterId),
      giverId: member.id, // Use the member ID, not the user ID
      receiverId: int(validatedData.memberId), // memberId in request is receiverId
      urgency: validatedData.urgency,
      self: validatedData.self === true || validatedData.self === "true",
      nameOfReferral: validatedData.nameOfReferral,
      mobile1: validatedData.mobile1,
      mobile2: validatedData.mobile2,
      email: validatedData.email,
      remarks: validatedData.remarks,
      addressLine1: validatedData.addressLine1,
      location: validatedData.location,
      addressLine2: validatedData.addressLine2,
      pincode: validatedData.pincode,
      status: validatedData.status || "pending",
    },
  });

  res.status(201).json(reference);
});

/**
 * Update an existing reference
 */
const updateReference = asyncHandler(async (req, res) => {
  const { id } = req.params;
  
  if (!id || isNaN(parseInt(id))) {
    throw createError(400, "Invalid reference ID");
  }
  
  // Define Zod schema for reference update validation
  const schema = z.object({
    date: z.string().optional(),
    noOfReferences: z.string().optional(),
    chapterId: z.number().int().positive().optional(),
    memberId: z.number().int().positive().optional(), // This is the receiverId in the database
    urgency: z.string().optional(),
    self: z.union([z.boolean(), z.string()]).optional(),
    nameOfReferral: z.string().optional(),
    mobile1: z.string().optional(),
    mobile2: z.string().optional(),
    email: z.string().email("Must be a valid email address.").optional().nullable(),
    remarks: z.string().optional(),
    addressLine1: z.string().optional(),
    addressLine2: z.string().optional(),
    location: z.string().optional(),
    pincode: z.string().optional(),
    status: z.string().optional()
  });

  // Use validateRequest utility for validation
  const validatedData = await validateRequest(schema, req.body);
  
  // Prepare data for update, only including fields that are provided
  const updateData = {};
  
  if (validatedData.date) updateData.date = new Date(validatedData.date);
  if (validatedData.noOfReferences !== undefined) {
    updateData.noOfReferences = validatedData.noOfReferences ? int(validatedData.noOfReferences) : null;
  }
  if (validatedData.chapterId) updateData.chapterId = int(validatedData.chapterId);
  if (validatedData.memberId) updateData.receiverId = int(validatedData.memberId); // memberId in request maps to receiverId
  if (validatedData.urgency !== undefined) updateData.urgency = validatedData.urgency;
  if (validatedData.self !== undefined) {
    updateData.self = validatedData.self === true || validatedData.self === "true";
  }
  if (validatedData.nameOfReferral) updateData.nameOfReferral = validatedData.nameOfReferral;
  if (validatedData.mobile1) updateData.mobile1 = validatedData.mobile1;
  if (validatedData.mobile2 !== undefined) updateData.mobile2 = validatedData.mobile2;
  if (validatedData.email !== undefined) updateData.email = validatedData.email;
  if (validatedData.remarks !== undefined) updateData.remarks = validatedData.remarks;
  if (validatedData.addressLine1 !== undefined) updateData.addressLine1 = validatedData.addressLine1;
  if (validatedData.location !== undefined) updateData.location = validatedData.location;
  if (validatedData.addressLine2 !== undefined) updateData.addressLine2 = validatedData.addressLine2;
  if (validatedData.pincode !== undefined) updateData.pincode = validatedData.pincode;
  if (validatedData.status) updateData.status = validatedData.status;

  const updated = await prisma.reference.update({
    where: { id: int(id) },
    data: updateData
  });

  res.json(updated);
});

/**
 * Delete a reference
 */
const deleteReference = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Check if reference exists
  const existingReference = await prisma.reference.findUnique({
    where: { id: int(id) },
  });

  if (!existingReference) {
    throw createError(404, "Reference not found");
  }

  // Delete the reference
  await prisma.reference.delete({
    where: { id: int(id) },
  });

  res.json({ success: true, message: "Reference deleted successfully" });
});

/**
 * Update reference status
 */
const updateReferenceStatus = asyncHandler(async (req, res) => {
  const { id } = req.params;
  
  if (!id || isNaN(parseInt(id))) {
    throw createError(400, "Invalid reference ID");
  }
  
  // Define Zod schema for status update validation
  const schema = z.object({
    status: z.enum(["pending", "contacted", "converted", "rejected"], {
      errorMap: () => ({ message: "Status must be one of: pending, contacted, converted, rejected" })
    }),
    date: z.string().optional(),
    comment: z.string().optional()
  });

  // Use validateRequest utility for validation
  const validatedData = await validateRequest(schema, req.body);

  // Check if reference exists
  const existingReference = await prisma.reference.findUnique({
    where: { id: int(id) },
  });

  if (!existingReference) {
    throw createError(404, "Reference not found");
  }

  // Create a transaction to update both reference status and add history entry
  const result = await prisma.$transaction(async (prisma) => {
    // Update reference status
    const updatedReference = await prisma.reference.update({
      where: { id: int(id) },
      data: { status: validatedData.status },
    });

    // Add status history entry
    await prisma.referenceStatusHistory.create({
      data: {
        referenceId: int(id),
        date: validatedData.date ? new Date(validatedData.date) : new Date(),
        status: validatedData.status,
        comment: validatedData.comment,
      },
    });

    return updatedReference;
  });

  // Include status history in the response
  const statusHistory = await prisma.referenceStatusHistory.findMany({
    where: { referenceId: int(id) },
    orderBy: { date: 'desc' },
  });

  res.json({
    ...result,
    statusHistory
  });
});

/**
 * Get received references for a member
 * These are references where the current member is the recipient (selected as the referral)
 */
const getReceivedReferences = asyncHandler(async (req, res) => {
  // Extract query parameters
  console.log(req.user.id);
  let {
    memberId,
    page = 1,
    limit = 10,
    search = "",
    status,
    sortBy = "date",
    sortOrder = "desc",
    exportData = "false",
  } = req.query;

  // Ensure valid pagination parameters
  const parsedPage = Math.max(1, parseInt(page, 10));
  const parsedLimit = Math.max(1, parseInt(limit, 10));
  const skip = (parsedPage - 1) * parsedLimit;

  // Get member ID from user ID if not provided
  if (!memberId) {
    const member = await prisma.member.findFirst({
      where: { userId: req.user.id },
      select: { id: true },
    });

    if (!member) {
      throw createError(404, "Member not found for current user");
    }

    memberId = member.id;
  }

  // Build where clause
  const where = {
    receiverId: parseInt(memberId, 10),
  };

  // Add search filter if present
  if (search && search.trim() !== "") {
    where.OR = [
      { nameOfReferral: { contains: search, mode: "insensitive" } },
      { remarks: { contains: search, mode: "insensitive" } },
    ];
  }

  // Add status filter if present
  if (status) {
    where.status = status;
  }

  // Get total count for pagination
  const totalReferences = await prisma.reference.count({ where });

  // Determine if we should skip pagination (for export)
  const paginationOptions = exportData === "true" 
    ? {} 
    : { skip, take: parsedLimit };

  // Get references
  const references = await prisma.reference.findMany({
    where,
    ...paginationOptions,
    orderBy: { [sortBy]: sortOrder.toLowerCase() },
    include: {
      giver: {
        select: {
          id: true,
          memberName: true,
          email: true,
        },
      },
      chapter: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });

  // Calculate total pages
  const totalPages = Math.ceil(totalReferences / parsedLimit);

  // Return the results
  if (exportData === 'true') {
    // For export, return all data in a format suitable for export
    res.json(references);
  } else {
    // For regular API requests, return paginated data
    res.json({
      data: references,
      pagination: {
        currentPage: parsedPage,
        totalPages,
        totalItems: totalReferences,
        hasNextPage: parsedPage < totalPages,
        hasPrevPage: parsedPage > 1,
      },
    });
  }
});

/**
 * Get member information for reference form
 */
const getMemberInfoForReference = asyncHandler(async (req, res) => {
  const { memberId } = req.params;
  
  if (!memberId) {
    throw createError(400, "Member ID is required");
  }
  
  const parsedMemberId = parseInt(memberId, 10);
  
  const member = await prisma.member.findUnique({
    where: { id: parsedMemberId },
    select: {
      id: true,
      memberName: true,
      email: true,
      mobile1: true,
      mobile2: true,
      addressLine1: true,
      addressLine2: true,
      location: true,
      pincode: true,
      organizationName: true
    }
  });
  
  if (!member) {
    throw createError(404, "Member not found");
  }
  
  res.json(member);
});

module.exports = {
  listReferences,
  getReferenceById,
  createReference,
  updateReference,
  deleteReference,
  updateReferenceStatus,
  getReceivedReferences,
  getMemberInfoForReference,
};
